---
title: "JVM 메모리 구조"
excerpt : "JVM 메모리 구조를 알아보자"
categories:
  - JAVA
tags:
  - JAVA
  - TIL
last_modified_at: 2021-06-14 T08:35
---
참조한 블로그 : [1](https://velog.io/@agugu95/%EC%9E%90%EB%B0%94%EC%99%80-JVM-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)



__Runtime Data Area__

- 메소드 영역:
  * 클래스 데이터 (클래스 변수)
  * 프로그램 실행 중 특정 클래스가 사용되면 JVM 해당 클래스 파일을 읽어서 클래스 데이터를 이곳에 저장 , 동시에 클래스 변수도 이곳에 생성
  * 인터페이스 정보도 저장됨
  * Runtime Constant Pool : 각 클래스, 인터페이스 상수 , 메소드 필드와 모든 레퍼런스가 담겨있음
  * 런타임 상수 풀의 역할은 이미 있는 메소드나 필드의 참조를 통해 중복을 막음


- 힙 영역:
  * 인스턴스(인스턴스 변수)
  * 인스턴스가 이곳에 생성
  * 동적 데이터가 할당되어 저장
  * 오랜 시간 참조가 없는 객체들은 가비지 컬렉을 통해 제거

  - 호출 스택 영: 예외처리 할 때 필요하다.
   * 메인 메소드(지역 변수)
   * 메소드 작업에 필요한 메모리 공간을 제공
   * 메소드가 호출되면 호출 스택에 메소드 활용을 위한 메모리가 할당
   * 메모리에서 메소드가 작업을 하는 동안 지역변수와 연산의 중간 결과가 저장
   * 메소드가 작업을 마치면 할당된 메모리 공간은 반환되어 비워짐
   * 호출스택에서 지금 실행중인 메소드: 언제나 제일 상위에 있는 메소드
   * 나머지는 대기중
   * 제일 상위의 메소드 아래의 메소드 : 상위의 메소드를 호출해서 사용중인 메소드


++
 * 리턴타입이 있는 메소드는 종료되기 직전 결과값을 반환
 * 자신을 호출한 메소드에게 결과값을 반환
 * 대기하고 있는 호출 메소드가 받아서 프로그램 진행
                                              ++
